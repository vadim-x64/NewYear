<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Новорічна Анімація</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            font-family: 'Comic Sans MS', sans-serif;
        }
        html {
            overflow: hidden;
            height: 100%;
        }

        body {
            overflow: hidden;
            background: #FFFFFF;
            cursor: default;
            position: fixed;
            width: 100%;
            height: 100vh;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;

        }

        body.loaded {
            opacity: 1;
        }

        #backgroundVideo {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 10;
        }

        #stringCanvas {
            width: 100%;
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 1;
        }

        .anchor {
            position: absolute;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 2;
        }

        .candy-container {
            position: absolute;
            transform-origin: center center;
            z-index: 3;
            cursor: grab;
            transition: filter 0.2s;
            will-change: transform;
        }

        .candy-container img {
            width: 120px;
        }

        .candy-container:active {
            cursor: grabbing;
        }

        .candy-img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        #modalOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.75);
            z-index: 100;
            display: none;
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.5s ease-in-out;
            cursor: pointer;
        }

        #modalOverlay.show {
            display: flex;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        #modalConfettiCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 102;
            display: none;
        }

        #modalConfettiCanvas.show {
            display: block;
        }

        #wishCard {
            position: relative;
            width: 100%;
            max-width: 800px;
            height: 100vh;
            animation: slideIn 0.6s ease-out;
            cursor: default;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #modalImageContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #modalBackgroundImage {
            width: 100%;
            height: 100%;
            object-fit: contain;
            object-position: center;
        }

        #wishContent {
            position: relative;
            z-index: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            width: 50%;
            height: 100%;
        }

        @keyframes slideIn {
            from {
                transform: translateY(-100px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        #wishCard h2 {
            color: #FFA600;
            font-size: 36px;
            text-align: center;
            text-shadow: 0px 2px 4px rgb(255, 145, 0);
            font-weight: bold;
            margin-top: 20px;
        }

        #wishText {
            color: #ffffff;
            font-size: 28px;
            line-height: 1.5;
            display: flex;
            text-align: center;
            align-items: center;
            max-width: 100%;
            height: 100%;
            overflow-wrap: break-word;
            padding: 0 20px;
        }

        #closeHint {
            position: absolute;
            bottom: 200px;
            left: 50%;
            transform: translateX(-50%);
            color: #EEEEEE;
            font-size: 14px;
            text-align: center;
            opacity: 0;
            transition: opacity 0.5s;
            z-index: 2;
        }

        #closeHint.show {
            opacity: 1;
        }

        @keyframes sparkleAnim {
            0%, 100% {
                opacity: 0;
                transform: scale(0.5);
            }
            50% {
                opacity: 1;
                transform: scale(1.2);
            }
        }

        #giftBox {
            position: absolute;
            width: 250px;
            height: 250px;
            cursor: pointer;
            z-index: 101;
            display: none;
            opacity: 0;
            transition: transform 0.2s;
        }

        #giftBox.show {
            display: block;
            animation: giftAppear 0.8s ease-out forwards, giftBounce 1.5s ease-in-out infinite 0.8s;
        }

        #giftBox:hover {
            transform: scale(1.1);
        }

        #giftBox.exploding {
            animation: giftExplode 0.1s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards !important;
        }

        @keyframes giftAppear {
            0% {
                opacity: 0;
                transform: translateY(-100px) scale(0.3) rotate(0deg);
            }
            60% {
                opacity: 1;
                transform: translateY(20px) scale(1.1) rotate(5deg);
            }
            80% {
                transform: translateY(-10px) scale(0.95) rotate(-3deg);
            }
            100% {
                opacity: 1;
                transform: translateY(0) scale(1) rotate(0deg);
            }
        }

        @keyframes giftBounce {
            0%, 100% {
                transform: translateY(0) rotate(0deg) scale(1);
            }
            10% {
                transform: translateY(-15px) rotate(-5deg) scale(1);
            }
            20% {
                transform: translateY(0) rotate(5deg) scale(1);
            }
            30% {
                transform: translateY(-10px) rotate(-3deg) scale(1);
            }
            40% {
                transform: translateY(0) rotate(3deg) scale(1);
            }
            50% {
                transform: translateY(-5px) rotate(0deg) scale(1);
            }
            60% {
                transform: translateY(0) rotate(0deg) scale(1);
            }
        }

        @keyframes giftExplode {
            0% {
                transform: scale(1) rotate(0deg);
                opacity: 1;
            }
            20% {
                transform: scale(1.3) rotate(180deg);
                opacity: 1;
            }
            50% {
                transform: scale(1.5) rotate(540deg);
                opacity: 0.6;
            }
            100% {
                transform: scale(0) rotate(1080deg);
                opacity: 0;
            }
        }

        #giftBox img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            filter: drop-shadow(0 5px 15px rgba(255, 215, 0, 0.5));
        }

        /* ============================================ */
        /* АДАПТАЦІЯ ДЛЯ МОБІЛЬНИХ ПРИСТРОЇВ */
        /* ============================================ */
        @media screen and (max-width: 768px) {
            /* ІКОНКА - ЗМЕНШЕНА */
            .candy-container img {
                width: 100px;
            }

            #wishCard {
                max-width: 100%;
                padding: 20px;



            }



            #modalImageContainer {
                padding: 0;
            }

            #modalBackgroundImage.mobile {
                content: url('src/assets/modalPhone.png');
                height: 100vh;
                width: auto;
            }

            #wishContent {
                width: 90%;
                padding: 20px;
                height: auto;
            }

            #wishCard h2 {
                font-size: 22px;
                color: #ffd700;
            }

            #wishText {
                font-size: 16px;
                line-height: 1.4;
                padding: 10px;
                max-height: 50vh;
                overflow-y: auto;
                height: auto;
            }

            #closeHint {
                bottom: 150px;
                font-size: 12px;
                padding: 0 20px;
                width: 80%;
            }

        }
    </style>
</head>
<body>
<video id="backgroundVideo" autoplay loop muted playsinline preload="metadata">
    <source src="src/assets/video.mp4" type="video/mp4">
</video>
<canvas id="canvas"></canvas>
<canvas id="stringCanvas"></canvas>
<div class="anchor" id="anchor"></div>
<div class="candy-container" id="candyContainer">
    <img src="src/assets/icon.png"
         alt="Candy"
         class="candy-img"
         id="candyImg"
         draggable="false">
</div>

<canvas id="modalConfettiCanvas"></canvas>

<div id="modalOverlay">
    <div id="wishCard">
        <div id="modalImageContainer">
            <img id="modalBackgroundImage" src="src/assets/modal.png" alt="Новорічна листівка">
        </div>

        <div id="wishContent">
            <h2>З Новим 2026 Роком!</h2>
            <div id="wishText"></div>
        </div>

        <div id="closeHint">Натисніть на екран, щоб закрити</div>
    </div>

    <div id="giftBox">
        <img src="src/assets/gift.png" alt="Подарунок">
    </div>
</div>

<script>
    window.addEventListener('load', () => {
        setTimeout(() => {
            document.body.classList.add('loaded');
        }, 500);
    });

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const stringCanvas = document.getElementById('stringCanvas');
    const stringCtx = stringCanvas.getContext('2d');
    const candyContainer = document.getElementById('candyContainer');
    const candyImg = document.getElementById('candyImg');
    const anchor = document.getElementById('anchor');

    const modalOverlay = document.getElementById('modalOverlay');
    const wishText = document.getElementById('wishText');
    const closeHint = document.getElementById('closeHint');
    const giftBox = document.getElementById('giftBox');
    const modalBackgroundImage = document.getElementById('modalBackgroundImage');

    const modalConfettiCanvas = document.getElementById('modalConfettiCanvas');
    const modalConfettiCtx = modalConfettiCanvas.getContext('2d');

    const confettiSound = new Audio('src/assets/audio.mp3');
    confettiSound.volume = 0.5;

    // Визначення мобільного пристрою
    const isMobile = window.innerWidth <= 768;

    // Встановлення правильного зображення для модального вікна
    if (isMobile) {
        modalBackgroundImage.classList.add('mobile');
        modalBackgroundImage.src = 'src/assets/modalPhone.png';
    }

    const garlandColors = [
        '#FF0000', '#00FF00', '#0080FF', '#FFD700',
        '#FF00FF', '#00FFFF', '#FFFF00', '#FF6600'
    ];

    const lightColors = [];
    for (let i = 0; i <= 30; i++) {
        lightColors.push(garlandColors[i % garlandColors.length]);
    }

    let blinkTime = 0;

    let wishes = [];
    fetch('src/assets/wishes.json')
        .then(response => response.json())
        .then(data => {
            wishes = data.wishes;
        })
        .catch(error => console.error('Помилка завантаження побажань:', error));

    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        stringCanvas.width = window.innerWidth;
        stringCanvas.height = window.innerHeight;
        modalConfettiCanvas.width = window.innerWidth;
        modalConfettiCanvas.height = window.innerHeight;
    }
    resizeCanvas();

    const anchorX = canvas.width / 2;
    const anchorY = 0;
    const stringLength = isMobile ? 200 : 300;

    let angle = (Math.random() - 0.5) * 0.3;
    let angleVelocity = (Math.random() - 0.5) * 0.05;
    const angleAcceleration = 0.0008;
    const angleDamping = 0.996;

    const confettiPullThreshold = isMobile ? 80 : 100;
    const confettiCooldown = 3000;
    let lastConfettiTime = 0;

    const stringSegments = 20;
    const stringPoints = [];

    for (let i = 0; i <= stringSegments; i++) {
        stringPoints.push({
            x: anchorX,
            y: anchorY + (stringLength / stringSegments) * i,
            vx: 0,
            vy: 0,
            prevX: anchorX,
            prevY: anchorY + (stringLength / stringSegments) * i
        });
    }

    let posX = anchorX;
    let posY = anchorY + stringLength;
    let velocityX = 0;
    let velocityY = 0;
    let isDragging = false;
    let dragOffsetX = 0;
    let dragOffsetY = 0;
    let lastMouseX = 0;
    let lastMouseY = 0;
    let mouseVelocityX = 0;
    let mouseVelocityY = 0;

    let candyTilt = 0;
    let lastPosX = posX;
    let lastPosY = posY;

    let confetti = [];
    let modalConfetti = [];
    let confettiTriggered = false;
    let wasStretched = false;
    let confettiAnimationFinished = false;

    anchor.style.left = anchorX + 'px';
    anchor.style.top = anchorY + 'px';

    function updatePositionFromAngle() {
        const targetX = anchorX + Math.sin(angle) * stringLength;
        const targetY = anchorY + Math.cos(angle) * stringLength;

        posX += (targetX - posX) * 0.3;
        posY += (targetY - posY) * 0.3;
    }

    updatePositionFromAngle();

    // Обробка touch events для мобільних
    function handleStart(e) {
        e.preventDefault();
        isDragging = true;

        const touch = e.touches ? e.touches[0] : e;
        const rect = candyContainer.getBoundingClientRect();

        dragOffsetX = touch.clientX - rect.left - rect.width / 2;
        dragOffsetY = touch.clientY - rect.top - rect.height / 2;
        lastMouseX = touch.clientX;
        lastMouseY = touch.clientY;
        mouseVelocityX = 0;
        mouseVelocityY = 0;
        velocityX = 0;
        velocityY = 0;
        confettiTriggered = false;
        wasStretched = false;
    }

    function handleMove(e) {
        if (!isDragging) return;
        e.preventDefault();

        const touch = e.touches ? e.touches[0] : e;
        const currentVelX = touch.clientX - lastMouseX;
        const currentVelY = touch.clientY - lastMouseY;

        mouseVelocityX = mouseVelocityX * 0.7 + currentVelX * 0.3;
        mouseVelocityY = mouseVelocityY * 0.7 + currentVelY * 0.3;

        lastMouseX = touch.clientX;
        lastMouseY = touch.clientY;

        const targetX = touch.clientX - dragOffsetX;
        const targetY = touch.clientY - dragOffsetY;

        const dx = targetX - anchorX;
        const dy = targetY - anchorY;
        const distance = Math.sqrt(dx * dx + dy * dy);

        const maxStretch = stringLength * 1.5;
        if (distance > maxStretch) {
            posX = anchorX + (dx / distance) * maxStretch;
            posY = anchorY + (dy / distance) * maxStretch;
            wasStretched = true;
        } else {
            posX += (targetX - posX) * 0.3;
            posY += (targetY - posY) * 0.3;
        }

        const currentTime = Date.now();
        const pullDistance = posY - (anchorY + stringLength);
        if (pullDistance > confettiPullThreshold && !confettiTriggered &&
            (currentTime - lastConfettiTime) >= confettiCooldown) {
            createConfettiBurst();
            confettiTriggered = true;
            lastConfettiTime = currentTime;
            confettiAnimationFinished = false;
            velocityY = -8;
            velocityX = (Math.random() - 0.5) * 4;

            confettiSound.currentTime = 0;
            confettiSound.play().catch(e => console.log('Audio play failed:', e));

            setTimeout(() => {
                showWishModal();
            }, 1000);
        }

        updatePosition();
    }

    function handleEnd(e) {
        if (!isDragging) return;
        e.preventDefault();

        isDragging = false;

        const dx = posX - anchorX;
        const dy = posY - anchorY;

        const currentDistance = Math.sqrt(dx * dx + dy * dy);
        if (currentDistance > stringLength * 1.2 || wasStretched) {
            const normalizedX = anchorX + (dx / currentDistance) * stringLength;
            const normalizedY = anchorY + (dy / currentDistance) * stringLength;

            velocityX = (normalizedX - posX) * 0.3 + mouseVelocityX * 0.8;
            velocityY = (normalizedY - posY) * 0.3 + mouseVelocityY * 0.8;
        } else {
            velocityX = mouseVelocityX * 0.8;
            velocityY = mouseVelocityY * 0.8;
        }

        angle = Math.atan2(dx, dy);

        const tangentialVelocity = velocityX * Math.cos(angle) - velocityY * Math.sin(angle);
        angleVelocity = tangentialVelocity / stringLength;

        angleVelocity += (Math.random() - 0.5) * 0.008;
    }

    // Додаємо обробники для миші та touch
    candyContainer.addEventListener('mousedown', handleStart);
    candyContainer.addEventListener('touchstart', handleStart, { passive: false });

    document.addEventListener('mousemove', handleMove);
    document.addEventListener('touchmove', handleMove, { passive: false });

    document.addEventListener('mouseup', handleEnd);
    document.addEventListener('touchend', handleEnd, { passive: false });

    function createConfettiBurst(fromX, fromY, isModal = false) {
        const colors = [
            '#FF0040', '#FF1493', '#FF69B4', '#FF4500',
            '#FFD700', '#FFFF00', '#00FF00', '#00FFFF',
            '#0080FF', '#4169E1', '#8B00FF', '#FF00FF',
            '#FF6347', '#32CD32', '#00CED1', '#FF1493',
            '#FFD700', '#FF8C00', '#00FF7F', '#7B68EE'
        ];
        const shapes = ['circle', 'square', 'triangle', 'star', 'heart', 'diamond'];

        const targetArray = isModal ? modalConfetti : confetti;
        const particleCount = isMobile ? 300 : 600;

        if (fromX !== undefined) {
            for (let i = 0; i < particleCount; i++) {
                const angle = (Math.PI * 2 * i) / particleCount + Math.random() * 0.5;
                const speed = Math.random() * 12 + 6;
                targetArray.push({
                    x: fromX,
                    y: fromY,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed - Math.random() * 4,
                    gravity: 0.15,
                    size: Math.random() * 10 + 4,
                    color: colors[Math.floor(Math.random() * colors.length)],
                    shape: shapes[Math.floor(Math.random() * shapes.length)],
                    rotation: Math.random() * 360,
                    rotationSpeed: Math.random() * 20 - 10,
                    opacity: 1,
                    life: 550 + Math.random() * 300,
                    maxLife: 550 + Math.random() * 300,
                    wobble: Math.random() * 2.5 - 1.25
                });
            }
        } else {
            const sideParticles = isMobile ? 150 : 300;

            for (let i = 0; i < sideParticles; i++) {
                const angle = Math.random() * Math.PI / 2.5 - Math.PI / 8;
                const speed = Math.random() * 6 + 4;
                targetArray.push({
                    x: 0,
                    y: Math.random() * canvas.height * 0.6 + canvas.height * 0.2,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed - Math.random() * 3,
                    gravity: 0.12,
                    size: Math.random() * 6 + 3,
                    color: colors[Math.floor(Math.random() * colors.length)],
                    shape: shapes[Math.floor(Math.random() * shapes.length)],
                    rotation: Math.random() * 360,
                    rotationSpeed: Math.random() * 10 - 5,
                    opacity: 1,
                    life: 400 + Math.random() * 200,
                    maxLife: 400 + Math.random() * 200,
                    wobble: Math.random() * 1.5 - 0.75
                });
            }

            for (let i = 0; i < sideParticles; i++) {
                const angle = Math.PI - (Math.random() * Math.PI / 2.5 - Math.PI / 8);
                const speed = Math.random() * 6 + 4;
                targetArray.push({
                    x: canvas.width,
                    y: Math.random() * canvas.height * 0.6 + canvas.height * 0.2,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed - Math.random() * 3,
                    gravity: 0.12,
                    size: Math.random() * 6 + 3,
                    color: colors[Math.floor(Math.random() * colors.length)],
                    shape: shapes[Math.floor(Math.random() * shapes.length)],
                    rotation: Math.random() * 360,
                    rotationSpeed: Math.random() * 10 - 5,
                    opacity: 1,
                    life: 400 + Math.random() * 200,
                    maxLife: 400 + Math.random() * 200,
                    wobble: Math.random() * 1.5 - 0.75
                });
            }
        }
    }

    function showWishModal() {
        if (wishes.length === 0) return;

        const randomWish = wishes[Math.floor(Math.random() * wishes.length)];
        modalOverlay.classList.add('show');
        wishText.textContent = '';
        closeHint.classList.remove('show');
        giftBox.classList.remove('show');
        giftBox.classList.remove('exploding');

        let charIndex = 0;
        const typewriterSpeed = isMobile ? 40 : 50;
        const typewriterInterval = setInterval(() => {
            if (charIndex < randomWish.length) {
                wishText.textContent += randomWish[charIndex];
                charIndex++;
            } else {
                clearInterval(typewriterInterval);
                setTimeout(() => {
                    showGiftBox();
                }, 500);
            }
        }, typewriterSpeed);
    }

    function showGiftBox() {
        giftBox.classList.add('show');

        setTimeout(() => {
            closeHint.classList.add('show');
        }, 3000);
    }

    giftBox.addEventListener('click', (e) => {
        e.stopPropagation();

        const rect = giftBox.getBoundingClientRect();
        const giftCenterX = rect.left + rect.width / 2;
        const giftCenterY = rect.top + rect.height / 2;

        giftBox.classList.add('exploding');

        confettiSound.currentTime = 0;
        confettiSound.play().catch(e => console.log('Audio play failed:', e));

        modalConfettiCanvas.classList.add('show');

        createConfettiBurst(giftCenterX, giftCenterY, true);

        setTimeout(() => {
            giftBox.classList.remove('show');
            giftBox.classList.remove('exploding');
            giftBox.style.animation = '';
        }, 400);
    });

    modalOverlay.addEventListener('click', (e) => {
        // Якщо натиснули на подарунок - не закриваємо
        if (e.target.closest('#giftBox')) {
            return;
        }

        // Інакше закриваємо модальне вікно
        modalOverlay.classList.remove('show');
        closeHint.classList.remove('show');
        giftBox.classList.remove('show');
        giftBox.classList.remove('exploding');
        giftBox.style.animation = '';
        modalConfettiCanvas.classList.remove('show');
        modalConfetti = [];
    });

    function updateString() {
        stringPoints[0].x = anchorX;
        stringPoints[0].y = anchorY;

        stringPoints[stringSegments].x = posX;
        stringPoints[stringSegments].y = posY;

        for (let i = 1; i < stringSegments; i++) {
            const point = stringPoints[i];

            const tempX = point.x;
            const tempY = point.y;

            point.x += (point.x - point.prevX) * 0.99;
            point.y += (point.y - point.prevY) * 0.99;
            point.y += 0.12;

            point.prevX = tempX;
            point.prevY = tempY;
        }

        for (let iter = 0; iter < 5; iter++) {
            for (let i = 0; i < stringSegments; i++) {
                const p1 = stringPoints[i];
                const p2 = stringPoints[i + 1];

                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const segmentLength = stringLength / stringSegments;
                const difference = (distance - segmentLength) / distance;

                const offsetX = dx * difference * 0.5;
                const offsetY = dy * difference * 0.5;

                if (i > 0) {
                    p1.x += offsetX;
                    p1.y += offsetY;
                }

                if (i < stringSegments - 1) {
                    p2.x -= offsetX;
                    p2.y -= offsetY;
                }
            }
        }
    }

    function drawString() {
        stringCtx.clearRect(0, 0, stringCanvas.width, stringCanvas.height);

        stringCtx.beginPath();
        stringCtx.moveTo(stringPoints[0].x, stringPoints[0].y);

        for (let i = 0; i < stringSegments; i++) {
            const p1 = stringPoints[i];
            const p2 = stringPoints[i + 1];
            const midX = (p1.x + p2.x) / 2;
            const midY = (p1.y + p2.y) / 2;

            stringCtx.quadraticCurveTo(p1.x, p1.y, midX, midY);
        }

        stringCtx.strokeStyle = '#2d5016';
        stringCtx.lineWidth = 2;
        stringCtx.lineCap = 'round';
        stringCtx.stroke();

        blinkTime += 0.05;

        for (let i = 0; i <= stringSegments; i++) {
            const point = stringPoints[i];

            const blinkOffset = i * 0.5;
            const brightness = 0.7 + Math.sin(blinkTime + blinkOffset) * 0.3;

            const bulbSize = isMobile ? 6 : 8;

            const gradient = stringCtx.createRadialGradient(
                point.x, point.y, 0,
                point.x, point.y, bulbSize * 2.5
            );

            const color = lightColors[i];
            gradient.addColorStop(0, color);
            gradient.addColorStop(0.3, color + '88');
            gradient.addColorStop(1, color + '00');

            stringCtx.globalAlpha = brightness * 0.6;
            stringCtx.fillStyle = gradient;
            stringCtx.beginPath();
            stringCtx.arc(point.x, point.y, bulbSize * 2.5, 0, Math.PI * 2);
            stringCtx.fill();

            stringCtx.globalAlpha = 1;
            stringCtx.fillStyle = color;
            stringCtx.shadowBlur = 15 * brightness;
            stringCtx.shadowColor = color;
            stringCtx.beginPath();
            stringCtx.arc(point.x, point.y, bulbSize, 0, Math.PI * 2);
            stringCtx.fill();

            stringCtx.shadowBlur = 0;
            stringCtx.fillStyle = 'rgba(255, 255, 255, ' + (brightness * 0.8) + ')';
            stringCtx.beginPath();
            stringCtx.arc(point.x - bulbSize * 0.3, point.y - bulbSize * 0.3, bulbSize * 0.4, 0, Math.PI * 2);
            stringCtx.fill();
        }

        stringCtx.globalAlpha = 1;
        stringCtx.shadowBlur = 0;
    }

    function updateCandyPhysics() {
        const moveSpeedX = posX - lastPosX;
        const moveSpeedY = posY - lastPosY;

        lastPosX = posX;
        lastPosY = posY;

        const targetTilt = moveSpeedX * 2;
        candyTilt += (targetTilt - candyTilt) * 0.15;

        candyTilt = Math.max(-45, Math.min(45, candyTilt));
    }

    function updatePosition() {
        updateCandyPhysics();

        candyContainer.style.left = (posX - 50) + 'px';
        candyContainer.style.top = (posY - 50) + 'px';

        candyContainer.style.transform = `rotate(${candyTilt - 200}deg)`;
    }

    function drawConfetti(particle, context) {
        context.save();
        context.translate(particle.x, particle.y);
        context.rotate(particle.rotation * Math.PI / 180);
        context.globalAlpha = particle.opacity;
        context.fillStyle = particle.color;
        context.strokeStyle = particle.color;
        context.lineWidth = 2;

        const size = particle.size;

        switch(particle.shape) {
            case 'circle':
                context.beginPath();
                context.arc(0, 0, size, 0, Math.PI * 2);
                context.fill();
                break;

            case 'square':
                context.fillRect(-size, -size, size * 2, size * 2);
                break;

            case 'triangle':
                context.beginPath();
                context.moveTo(0, -size * 1.2);
                context.lineTo(size * 1.2, size * 1.2);
                context.lineTo(-size * 1.2, size * 1.2);
                context.closePath();
                context.fill();
                break;

            case 'star':
                drawStar(context, 0, 0, 5, size * 1.3, size * 0.6);
                break;

            case 'heart':
                drawHeart(context, size);
                break;

            case 'diamond':
                context.beginPath();
                context.moveTo(0, -size * 1.3);
                context.lineTo(size * 0.8, 0);
                context.lineTo(0, size * 1.3);
                context.lineTo(-size * 0.8, 0);
                context.closePath();
                context.fill();
                break;
        }

        context.restore();
    }

    function drawStar(context, cx, cy, spikes, outerRadius, innerRadius) {
        let rot = Math.PI / 2 * 3;
        const step = Math.PI / spikes;
        context.beginPath();
        context.moveTo(cx, cy - outerRadius);

        for (let i = 0; i < spikes; i++) {
            let x = cx + Math.cos(rot) * outerRadius;
            let y = cy + Math.sin(rot) * outerRadius;
            context.lineTo(x, y);
            rot += step;
            x = cx + Math.cos(rot) * innerRadius;
            y = cy + Math.sin(rot) * innerRadius;
            context.lineTo(x, y);
            rot += step;
        }
        context.lineTo(cx, cy - outerRadius);
        context.closePath();
        context.fill();
    }

    function drawHeart(context, size) {
        context.beginPath();
        context.moveTo(0, size * 0.3);
        context.bezierCurveTo(-size * 1.2, -size * 0.6, -size * 1.8, size * 0.5, 0, size * 1.5);
        context.bezierCurveTo(size * 1.8, size * 0.5, size * 1.2, -size * 0.6, 0, size * 0.3);
        context.closePath();
        context.fill();
    }

    function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        modalConfettiCtx.clearRect(0, 0, modalConfettiCanvas.width, modalConfettiCanvas.height);

        if (!isDragging) {
            if (Math.abs(velocityX) > 0.01 || Math.abs(velocityY) > 0.01) {
                posX += velocityX;
                posY += velocityY;

                velocityX *= 0.95;
                velocityY *= 0.95;

                velocityY += 0.3;

                const dx = posX - anchorX;
                const dy = posY - anchorY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > stringLength) {
                    posX = anchorX + (dx / distance) * stringLength;
                    posY = anchorY + (dy / distance) * stringLength;

                    angle = Math.atan2(dx, dy);
                    const tangentialVelocity = velocityX * Math.cos(angle) - velocityY * Math.sin(angle);
                    angleVelocity = tangentialVelocity / stringLength;

                    velocityX = 0;
                    velocityY = 0;
                }
            } else {
                const angularAcceleration = -angleAcceleration * Math.sin(angle);
                angleVelocity += angularAcceleration;
                angleVelocity *= angleDamping;
                angle += angleVelocity;

                if (Math.abs(angleVelocity) > 0.001) {
                    angle += (Math.random() - 0.5) * 0.0003;
                }

                updatePositionFromAngle();
            }

            updatePosition();
        }

        updateString();
        drawString();

        confetti = confetti.filter(particle => {
            particle.vy += particle.gravity;
            particle.vx += particle.wobble * 0.05;
            particle.x += particle.vx;
            particle.y += particle.vy;
            particle.rotation += particle.rotationSpeed;
            particle.life--;

            if (particle.life < 150) {
                particle.opacity = particle.life / 150;
            }

            drawConfetti(particle, ctx);

            return particle.life > 0 &&
                particle.y < canvas.height + 100 &&
                particle.x > -100 &&
                particle.x < canvas.width + 100;
        });

        modalConfetti = modalConfetti.filter(particle => {
            particle.vy += particle.gravity;
            particle.vx += particle.wobble * 0.05;
            particle.x += particle.vx;
            particle.y += particle.vy;
            particle.rotation += particle.rotationSpeed;
            particle.life--;

            if (particle.life < 200) {
                particle.opacity = particle.life / 200;
            }

            drawConfetti(particle, modalConfettiCtx);

            return particle.life > 0 &&
                particle.y < modalConfettiCanvas.height + 100 &&
                particle.x > -100 &&
                particle.x < modalConfettiCanvas.width + 100;
        });

        requestAnimationFrame(animate);
    }

    window.addEventListener('resize', () => {
        const wasMobile = isMobile;
        const isNowMobile = window.innerWidth <= 768;

        if (wasMobile !== isNowMobile) {
            location.reload();
        }

        resizeCanvas();
    });

    animate();
</script>
</body>
</html>